---
title: [RK3399] PCI 设备驱动分析
tags: PCI
grammar_cjkRuby: true
---

##  基本概念
### 概述
每个PCI设备有许多地址配置的寄存器，初始化时要通过这些寄存器来配置该设备的总线地址，一旦完成配置以后，CPU就可以访问该设备的各项资源了。
PCI标准规定每个设备的配置寄存器组最多可以有256个连续的字节空间。开头64个字节叫头部，分为0型（PCI设备）和1型（PCI桥）头部，头部开头16个字节是设备的类型、型号和厂商等。
这些头部寄存器除了地址配置的作用，还能使CPU能够探测到相应设备的存在，这样就不需要用户告诉系统都有哪些设备了，而是改由CPU通过一个号称枚举的过程自动扫描探测所有挂接在PCI总线上的设备。
设备的配置寄存器组采用相同的地址，由所在总线的PCI桥在访问时附加上其他条件区分，对于I386处理器，有两个32位寄存器，0XCF8为地址寄存器，0XCFC为数据寄存器。
地址寄存器写入的内容包括总线号，设备号，功能号。逻辑地址（XX:YY.Z），XX表示PCI总线号，最多256个总线。YY表示PCI设备号，最多32个设备。Z表示PCI设备功能号，最多8个功能。
这些内容也可以通过 lspci 命令看到。具体的方法见 《PCI 设备调试步骤》 一章。

### 总线架构
所有的根总线都链接在pci_root_buses链表中。
pci_bus ->device 链表链接着该总线下的所有设备。
pci_bus->children 链表链接着它的下层总线。
对于pci_dev来说，pci_dev->bus 指向它所属的 pci_bus。 pci_dev->bus_list 链接在它所属bus的device链表上。
此外，所有pci设备都链接在 pci_device 链表中。


### 驱动划分
PCI设备驱动实际包括 **Linux PCI 驱动** 和 **设备本身驱动**两部分
Linux PCI 驱动 内核已经写好了。对这部分，我们需要明白内核完成了什么。
设备本身驱动 需要我们自己实现（或者移植）。

本文分析的是 Linux PCI 设备驱动的代码。

**Linux PCI 初始化代码**逻辑上分为三个部分：
(1) PCI设备驱动程序（即上面提到的Linux PCI设备驱动）
这个伪设备驱动程序从总线0开始查询PCI系统并且定位系统中所有的PCI设备和PCI桥。它建立一个
可以用来描述这个PCI系统拓朴层次的数据结构链表。并且对所有的发现的PCI桥编号。
(2) PCI BIOS
这个软件层提供在bib-pci-bios归约中描述的服务。虽然Alpha AXP不提供BIOS服务，在其Linux
版本中包含了相应的功能。
(3) PCI Fixup 
与特定系统相关的PCI初始化修补代码


## 驱动概览

### 

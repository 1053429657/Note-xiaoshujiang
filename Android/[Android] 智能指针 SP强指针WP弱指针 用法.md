---
title: Android 智能指针 SP强指针WP弱指针 用法
tags: Android,智能指针,C++
grammar_cjkRuby: true
---
这两天分析问题的时候看到了 sp< xxx > wp< xxx > 这样的类型定义。查阅资料后了解到这是 Android 中智能指针的用法。
## 概念
智能指针是 C++ 中的概念。
通过**引用计数**的方法，解决对象自动释放的问题。
在 C++ 编程中，有两个头疼的问题。
1. 忘记释放动态申请的对象而造成内存泄漏
2. 对象在一个地方释放后，又在别的地方被使用，从而引起内存访问错误

所以采用智能指针后，动态申请的内存将会被自动释放，不需要 delete 来释放对象，也不用考虑一个对象是否在其他地方被释放了。
Android智能指针相关的源代码在下面两个文件中：
frameworks\base\include\utils\RefBase.h
frameworks\base\libs\utils\RefBase.cpp

Android 中有两种指针类型，**强指针 SP(strong pointer) 弱指针 WP(weak pointer)**
自动释放的原理在于可以被智能指针引用的对象都同时被**附加了另外一个 weakref_impl类型**的对象，这个对象中负责记录对象的强指针引用计数和弱指针引用计数。这个对象是Android智能指针的实现内部使用的，智能指针的使用者看不到这个对象。弱指针操作的就是这个对象，只有当强引用计数和弱引用计数都为0时，这个对象才会被销毁。
### 强指针
强指针与一般意义的智能指针概念相同，通过**引用计数**来记录有多少使用者在使用一个对象，如果所有使用者都放弃了对该对象的引用，则该对象将被自动销毁。
### 弱指针
弱指针也指向一个对象，但是**弱指针仅仅记录该对象的地址**，不能通过弱指针来访问该对象，也就是说不能通过弱智真来调用对象的成员函数或访问对象的成员变量。要想访问弱指针所指向的对象，需首先将弱指针升级为强指针（通过wp类所提供的promote()方法）。弱指针所指向的对象是有可能在其它地方被销毁的，如果对象已经被销毁，wp的promote()方法将返回空指针，这样就能避免出现地址访问错的情况。


## 用法
假设现在有一个类MyClass，如果要使用智能指针来引用这个类的对象，那么这个类需满足下列两个前提条件：
1.  这个类是基类 RefBase 的子类或间接子类；
2.  这个类必须定义虚构造函数，即它的构造函数需要这样定义：
```cpp
virtual ~MyClass(); 
```
满足了上述条件的类就可以定义Android智能指针了，定义方法和普通指针类似。比如普通指针是这样定义：
```cpp
MyClass* p_obj; 
```
Android智能指针是这样定义：
```cpp
sp< MyClass> p_obj; 
```
注意不要定义成 sp< MyClass>* p_obj。初学者容易犯这种错误，这样实际上相当于定义了一个指针的指针。尽管在语法上没有问题，但是最好永远不要使用这样的定义。

### 强指针
定义了一个智能指针的变量，就可以象普通指针那样使用它，包括赋值、访问对象成员、作为函数的返回值、作为函数的参数等。比如：
```cpp
    p_obj = new MyClass();   
    // 注意不要写成 p_obj = new sp< MyClass> 
    sp< MyClass> p_obj2 = p_obj;  
    p_obj->func();  
    p_obj = create_obj();  
    some_func(p_obj); 
```
不要试图 delete 一个 Android 智能指针，即 delete p_obj。**不要担心对象的销毁问题**，智能指针的最大作用就是自动销毁不再使用的对象。不需要再使用一个对象后，直接将指针赋值为NULL即可：
```cpp
	p_obj = NULL;
```

### 弱指针
```cpp
    wp< MyClass> wp_obj = new MyClass();  
    p_obj = wp_obj.promote();   
    // 升级为强指针。不过这里要用.而不是->，真是有负其指针之名啊  
    wp_obj = NULL; 
```


## 缺点
Android 智能指针用起来是很方便，在一般情况下最好使用智能指针来代替普通指针。
但是需要知道一个**智能指针其实是一个对象**，而不是一个真正的指针，因此其**运行效率是远远比不上普通指针的**。所以在对运行效率敏感的地方，最好还是不要使用智能指针为好。










